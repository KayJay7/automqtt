"""
This type stub file was generated by pyright.
"""

"""Filename globbing utility."""
__all__ = ["glob", "iglob", "escape", "translate"]
def glob(pathname, *, root_dir=..., dir_fd=..., recursive=..., include_hidden=...): # -> list[Any]:
    """Return a list of paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la
    fnmatch. Unlike fnmatch, filenames starting with a
    dot are special cases that are not matched by '*' and '?'
    patterns by default.

    If `include_hidden` is true, the patterns '*', '?', '**'  will match hidden
    directories.

    If `recursive` is true, the pattern '**' will match any files and
    zero or more directories and subdirectories.
    """
    ...

def iglob(pathname, *, root_dir=..., dir_fd=..., recursive=..., include_hidden=...): # -> chain[Any] | Generator[Any, Any, None]:
    """Return an iterator which yields the paths matching a pathname pattern.

    The pattern may contain simple shell-style wildcards a la
    fnmatch. However, unlike fnmatch, filenames starting with a
    dot are special cases that are not matched by '*' and '?'
    patterns.

    If recursive is true, the pattern '**' will match any files and
    zero or more directories and subdirectories.
    """
    ...

_deprecated_function_message = ...
def glob0(dirname, pattern): # -> list[Any]:
    ...

def glob1(dirname, pattern): # -> list[Any]:
    ...

magic_check = ...
magic_check_bytes = ...
def has_magic(s): # -> bool:
    ...

def escape(pathname):
    """Escape all special characters.
    """
    ...

_special_parts = ...
_dir_open_flags = ...
_no_recurse_symlinks = ...
def translate(pat, *, recursive=..., include_hidden=..., seps=...): # -> LiteralString:
    """Translate a pathname with shell wildcards to a regular expression.

    If `recursive` is true, the pattern segment '**' will match any number of
    path segments.

    If `include_hidden` is true, wildcards can match path segments beginning
    with a dot ('.').

    If a sequence of separator characters is given to `seps`, they will be
    used to split the pattern into segments and match path separators. If not
    given, os.path.sep and os.path.altsep (where available) are used.
    """
    ...

class _GlobberBase:
    """Abstract class providing shell-style pattern matching and globbing.
    """
    def __init__(self, sep, case_sensitive, case_pedantic=..., recursive=...) -> None:
        ...
    
    @staticmethod
    def lexists(path):
        """Implements os.path.lexists().
        """
        ...
    
    @staticmethod
    def scandir(path):
        """Like os.scandir(), but generates (entry, name, path) tuples.
        """
        ...
    
    @staticmethod
    def concat_path(path, text):
        """Implements path concatenation.
        """
        ...
    
    def compile(self, pat, altsep=...): # -> Callable[..., Any]:
        ...
    
    def selector(self, parts): # -> Callable[..., Generator[Any, Any, None]] | Callable[..., Generator[Any, Any, None] | Any] | Callable[..., Any]:
        """Returns a function that selects from a given path, walking and
        filtering according to the glob-style pattern parts in *parts*.
        """
        ...
    
    def special_selector(self, part, parts): # -> Callable[..., Generator[Any, Any, None] | Any]:
        """Returns a function that selects special children of the given path.
        """
        ...
    
    def literal_selector(self, part, parts): # -> Callable[..., Any]:
        """Returns a function that selects a literal descendant of a path.
        """
        ...
    
    def wildcard_selector(self, part, parts): # -> Callable[..., Generator[Any, Any, None]]:
        """Returns a function that selects direct children of a given path,
        filtering by pattern.
        """
        ...
    
    def recursive_selector(self, part, parts): # -> Callable[..., Generator[Any, Any, None]]:
        """Returns a function that selects a given path and all its children,
        recursively, filtering by pattern.
        """
        ...
    
    def select_exists(self, path, exists=...): # -> Generator[Any, Any, None]:
        """Yields the given path, if it exists.
        """
        ...
    


class _StringGlobber(_GlobberBase):
    """Provides shell-style pattern matching and globbing for string paths.
    """
    lexists = ...
    concat_path = ...
    @staticmethod
    def scandir(path): # -> Generator[tuple[DirEntry[str], str, str], None, None]:
        ...
    


class _PathGlobber(_GlobberBase):
    """Provides shell-style pattern matching and globbing for pathlib paths.
    """
    @staticmethod
    def lexists(path):
        ...
    
    @staticmethod
    def scandir(path): # -> Generator[tuple[Any, Any, Any], None, None]:
        ...
    
    @staticmethod
    def concat_path(path, text):
        ...
    


