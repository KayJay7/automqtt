"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod, abstractproperty
from pathlib_abc._glob import _PathGlobber
from pathlib_abc._os import (
    copyfileobj,
    ensure_different_files,
    ensure_distinct_paths,
    magic_open,
)
from typing import (
    Any,
    Callable,
    Iterable,
    Iterator,
    LiteralString,
    Optional,
    Protocol,
    runtime_checkable,
    Self,
)
from io import text_encoding
import posixpath

"""
Protocols for supporting classes in pathlib.
"""
__all__ = [
    "PathParser",
    "PathInfo",
    "JoinablePath",
    "ReadablePath",
    "WritablePath",
    "magic_open",
    "OnError",
]

type OnError = Callable[[OSError], None]

@runtime_checkable
class PathParser(Protocol):
    """Protocol for path parsers, which do low-level path manipulation.

    Path parsers provide a subset of the os.path API, specifically those
    functions needed to provide JoinablePath functionality. Each JoinablePath
    subclass references its path parser via a 'parser' class attribute.
    """

    sep: str
    altsep: Optional[str]
    def split(self, path: str) -> tuple[str, str]: ...
    def splitext(self, path: str) -> tuple[str, str]: ...
    def normcase(self, path: str) -> str: ...

@runtime_checkable
class PathInfo(Protocol):
    """Protocol for path info objects, which support querying the file type.
    Methods may return cached results.
    """

    def exists(self, *, follow_symlinks: bool = ...) -> bool: ...
    def is_dir(self, *, follow_symlinks: bool = ...) -> bool: ...
    def is_file(self, *, follow_symlinks: bool = ...) -> bool: ...
    def is_symlink(self) -> bool: ...

class JoinablePath(ABC):
    """Abstract base class for pure path objects.

    This class *does not* provide several magic methods that are defined in
    its implementation PurePath. They are: __init__, __fspath__, __bytes__,
    __reduce__, __hash__, __eq__, __lt__, __le__, __gt__, __ge__.
    """

    __slots__ = ...

    @property
    @abstractmethod
    def parser(self) -> PathParser:
        """Implementation of pathlib._types.Parser used for low-level path
        parsing and manipulation.
        """
        ...

    @abstractmethod
    def with_segments(self, *pathsegments: str) -> Self:
        """Construct a new path object from any number of path-like objects.
        Subclasses may override this method to customize how new path objects
        are created from methods like `iterdir()`.
        """
        ...

    @abstractmethod
    def __str__(self) -> str:
        """Return the string representation of the path, suitable for
        passing to system calls."""
        ...

    @property
    def anchor(self) -> str:
        """The concatenation of the drive and root, or ''."""
        ...

    @property
    def name(self) -> str:
        """The final path component, if any."""
        ...

    @property
    def suffix(self) -> str:
        """
        The final component's last suffix, if any.

        This includes the leading period. For example: '.txt'
        """
        ...

    @property
    def suffixes(self) -> list[str]:
        """
        A list of the final component's suffixes, if any.

        These include the leading periods. For example: ['.tar', '.gz']
        """
        ...

    @property
    def stem(self) -> str:
        """The final path component, minus its last suffix."""
        ...

    def with_name(self, name: str) -> Self:
        """Return a new path with the file name changed."""
        ...

    def with_stem(self, stem: str) -> Self:
        """Return a new path with the stem changed."""
        ...

    def with_suffix(self, suffix: str) -> Self:
        """Return a new path with the file suffix changed.  If the path
        has no suffix, add given suffix.  If the given suffix is an empty
        string, remove the suffix from the path.
        """
        ...

    @property
    def parts(self) -> tuple[str, ...]:
        """An object providing sequence-like access to the
        components in the filesystem path."""
        ...

    def joinpath(self, *pathsegments: str) -> Self:
        """Combine this path with one or several arguments, and return a
        new path representing either a subpath (if all arguments are relative
        paths) or a totally different path (if one of the arguments is
        anchored).
        """
        ...

    def __truediv__(self, key: str) -> Self: ...
    def __rtruediv__(self, key: str) -> Self: ...
    @property
    def parent(self) -> Self:
        """The logical parent of the path."""
        ...

    @property
    def parents(self) -> tuple[Self, ...]:
        """A sequence of this path's logical parents."""
        ...

    def full_match(self, pattern: str) -> bool:
        """
        Return True if this path matches the given glob-style pattern. The
        pattern is matched against the entire path.
        """
        ...

class ReadablePath(JoinablePath):
    """Abstract base class for readable path objects.

    The Path class implements this ABC for local filesystem paths. Users may
    create subclasses to implement readable virtual filesystem paths, such as
    paths in archive files or on remote storage systems.
    """

    __slots__ = ...
    @property
    @abstractmethod
    def info(self) -> PathInfo:
        """
        A PathInfo object that exposes the file type and other file attributes
        of this path.
        """
        ...

    @abstractmethod
    def __open_rb__(self, buffering: bool = ...):
        """
        Open the file pointed to by this path for reading in binary mode and
        return a file object, like open(mode='rb').
        """
        ...

    def read_bytes(self) -> str | Any:
        """
        Open the file in bytes mode, read it, and close the file.
        """
        ...

    def read_text(self, encoding=..., errors=..., newline=...):  # -> str | Any:
        """
        Open the file in text mode, read it, and close the file.
        """
        ...

    @abstractmethod
    def iterdir(self) -> Iterable[Self]:
        """Yield path objects of the directory contents.

        The children are yielded in arbitrary order, and the
        special entries '.' and '..' are not included.
        """
        ...

    def glob(self, pattern, *, recurse_symlinks=...):  # -> Generator[Any, Any, None]:
        """Iterate over this subtree and yield all existing files (of any
        kind, including directories) matching the given relative pattern.
        """
        ...

    def walk(
        self,
        top_down: bool = ...,
        on_error: OnError | Any = ...,
        follow_symlinks: bool = ...,
    ) -> Iterator[tuple[Self, list[str], list[str]]]:
        """Walk the directory tree from this directory, similar to os.walk()."""

        ...

    @abstractmethod
    def readlink(self):
        """
        Return the path to which the symbolic link points.
        """
        ...

    def copy(self, target, **kwargs):
        """
        Recursively copy this file or directory tree to the given destination.
        """
        ...

    def copy_into(self, target_dir, **kwargs):
        """
        Copy this file or directory tree into the given existing directory.
        """
        ...

class WritablePath(JoinablePath):
    """Abstract base class for writable path objects.

    The Path class implements this ABC for local filesystem paths. Users may
    create subclasses to implement writable virtual filesystem paths, such as
    paths in archive files or on remote storage systems.
    """

    __slots__ = ...
    @abstractmethod
    def symlink_to(self, target, target_is_directory=...):
        """
        Make this path a symlink pointing to the target path.
        Note the order of arguments (link, target) is the reverse of os.symlink.
        """
        ...

    @abstractmethod
    def mkdir(self):
        """
        Create a new directory at this given path.
        """
        ...

    @abstractmethod
    def __open_wb__(self, buffering=...):
        """
        Open the file pointed to by this path for writing in binary mode and
        return a file object, like open(mode='wb').
        """
        ...

    def write_bytes(self, data):  # -> int | Any:
        """
        Open the file in bytes mode, write to it, and close the file.
        """
        ...

    def write_text(self, data, encoding=..., errors=..., newline=...):  # -> int | Any:
        """
        Open the file in text mode, write to it, and close the file.
        """
        ...

_PathParser = PathParser
_JoinablePath = JoinablePath
_ReadablePath = ReadablePath
_WritablePath = WritablePath
